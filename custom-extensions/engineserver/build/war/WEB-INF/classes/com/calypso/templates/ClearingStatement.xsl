<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:stmt="urn:com:calypso:clearing:statement" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:stmtext="xalan://com.calypso.tk.bo.StatementDataTypeFormatter" xmlns:exslt="http://exslt.org/common"
	xmlns:func="http://exslt.org/functions"	 xmlns:my="http://example.org/my"
	extension-element-prefixes="stmtext exslt func" exclude-result-prefixes="xs stmtext my">
	
	<xsl:key name="marginsByCcy"
		match="stmt:sectionElement[@id='initialMarginSummaryTable']//stmt:row/stmt:metaData/stmt:entry[@key='ccy']" use="text()" />
	<xsl:key name="marginCallActivity" match="stmt:sectionElement[@id='marginCallActivity']/stmt:row/stmt:metaData/stmt:entry[@key='ccp']"
		use="text()" />
	<xsl:key name="pendingMarginCallActivity"
		match="stmt:sectionElement[@id='pendingMarginCallActivity']/stmt:row/stmt:metaData/stmt:entry[@key='ccp']" use="text()" />
	<xsl:key name="clearingServicesKey" match="stmt:sectionElement[@id='initialMarginTable']/stmt:metaData" use="concat(stmt:entry[@key='ccp'], '|', stmt:entry[@key='product'])" />

	<xsl:variable name="baseCurrency">
		<xsl:value-of select="//stmt:ClearingStatement/stmt:metaData/stmt:entry[@key='baseCurrency']" />
	</xsl:variable>

	<xsl:variable name="rawDate">
		<xsl:value-of select="//stmt:ClearingStatement/stmt:metaData/stmt:entry[@key='statementDate']" />
	</xsl:variable>

	<xsl:variable name="pricingEnv">
		<xsl:value-of select="//stmt:ClearingStatement/stmt:metaData/stmt:entry[@key='pricingEnv']" />
	</xsl:variable>

	<xsl:template match="/stmt:ClearingStatement">
		<html>
			<head>
				<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
				<title>Clearing Statement</title>
				<style type="text/css">

					body {
					text-align: justify;
					font-family: sans-serif;
					}

					div.SECTION {
					margin-left: 1em;
					}

					div.SECTION_ELEMENT {
					margin-left: 2em;
					}

					div.SUB_SECTION_ELEMENT {
					margin-left: 2em;
					}

					div.INNER_DIV {
					margin-left: 2em;
					}

					p.FOOTER {
					text-align: center;
					font-size: 8px;
					}

					p.TITLE {
					text-align: center;
					font-size: 1.5em;
					text-decoration:
					underline;
					}

					p.SECTION_TITLE {
					text-align: justify;
					font-size: 1.25em;
					}

					p.SECTION_ELEMENT_TITLE {
					text-align: justify;
					font-size: 1.0em;
					}

					p.SECTION_ELEMENT_SUB_TITLE {
					text-align: justify;
					font-size: 0.8em;
					}

					p.DETAIL {
					margin-left: 1em;
					font-size: 0.8em;
					font-style: italic;
					}

					table {
					border: 1.0px solid black;
					border-collapse: collapse;
					font-size: 0.8em;
					}

					th {
					border: 1.0px solid black;
					background-color: #f97777;
					white-space: nowrap;
					text-align: center;
					padding: 0.40em;
					}

					tr.SUB_TOTAL {
					background-color: #DDDDDD;
					}

					tr.TOTAL {
					background-color: #BBBBBB;
					}

					td {
					border: 1.0px solid black;
					white-space: nowrap;
					text-align: right;
					padding: 0.40em;
					}

					td.SUB_TOTAL {
					font-weight: bold;
					}

					td.TOTAL {
					text-align: left;
					font-weight: bold;
					}

					td.PRINCIPAL_CCY {
					background-color: #BBFFCC;
					}

				</style>
			</head>
			<body>
				<p>
					<img src="https://www.calypso.com/images/logo.gif" alt="Logo" />
				</p>
				<p class="TITLE">
					<xsl:value-of select="stmt:metaData/stmt:entry[@key='mode']" />
					Statement on
					<xsl:value-of select="stmt:metaData/stmt:entry[@key='statementDate']" />
					for
					<xsl:value-of select="stmt:metaData/stmt:entry[@key='receiver']" />
				</p>
				<xsl:value-of select="stmt:metaData/stmt:entry[@key='receiver']" />
				<br />
				<xsl:value-of select="stmt:metaData/stmt:entry[@key='receiverAddress']" />
				<br />
				<xsl:value-of select="stmt:metaData/stmt:entry[@key='receiverCity']" />
				,
				<xsl:value-of select="stmt:metaData/stmt:entry[@key='receiverState']" />
				,
				<xsl:value-of select="stmt:metaData/stmt:entry[@key='receiverZip']" />
				<br />
				<p />
				<xsl:apply-templates select="stmt:section" />
				<p class="FOOTER">
					Statement generated by Calypso Technology
					<xsl:value-of select="concat(', ', substring(string(stmt:metaData/stmt:entry[@key='statementDate']), 0, 5), '.')" />
				</p>
			</body>
		</html>
	</xsl:template>

	<xsl:template match="stmt:section">
		<xsl:variable name="section" select="." />
		<xsl:variable name="title" select="@id" />
		<div class="SECTION">
			<p class="SECTION_TITLE">
				<xsl:value-of select="stmtext:getTranslation('title', $title)" />
			</p>
			<div class="SECTION_ELEMENT">
				<xsl:apply-templates select="stmt:sectionElement[@id='clearingCashFlowsSummaryTable']" />
				<br />
				<xsl:apply-templates select="stmt:sectionElement[@id='separateSettlementSummaryTable']" />
				<br />
				<xsl:apply-templates select="stmt:sectionElement[@id='vmtsLedgerSummaryTable']" />
				<br />
				<xsl:apply-templates select="stmt:sectionElement[@id='initialMarginSummaryTables']" />
				<br />
				<!-- Below line needed for backwards compatibility? -->
				<xsl:apply-templates select="stmt:sectionElement[@id='initialMarginSummaryTable']" />
				<br />

				<xsl:choose>
					<xsl:when
						test="$title = 'financialSummary' and count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='summaryOfPaymentsTable']) = 0">
						<br />
						<xsl:variable name="title" select="@id" />
						<p class="SECTION_ELEMENT_TITLE">
							<xsl:value-of select="stmtext:getTranslation('title', 'summaryOfPaymentsTable')" />
						</p>
						<table>
							<tr class="HEADER">
								<th></th>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
						         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
						         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
						            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
						            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<th>
											<xsl:choose>
												<xsl:when test="text() = 'Total'">
													<xsl:value-of select="concat(./text(), ' (', $baseCurrency, ')')" />
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="." />
												</xsl:otherwise>
											</xsl:choose>
										</th>
									</xsl:if>
								</xsl:for-each>
							</tr>
							<tr>
								<td>Clearing Cash Flows</td>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
						         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
						         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
						            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
						            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<xsl:choose>
											<xsl:when
												test="count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[text() = $Ccy]) = 0">
												<xsl:choose>
													<xsl:when test="$Ccy = 'Total'">
														<td>
															<xsl:value-of
																select="stmtext:formatNumber(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'Total Equity plus Pending Cash']/stmt:cell[@id = 'total']/stmt:value, $baseCurrency)" />
														</td>
													</xsl:when>
													<xsl:otherwise>
														<td>
															<xsl:value-of
																select="stmtext:formatNumber(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'Total Equity plus Pending Cash']/stmt:cell[@id = $Ccy]/stmt:value, $Ccy)" />
														</td>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:when>
											<xsl:otherwise>
												<td>0.0</td>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:if>
								</xsl:for-each>
							</tr>
							<tr>
								<td>Initial Margin</td>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
						         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
						         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
						            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or 
						            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<xsl:choose>
											<xsl:when test="$Ccy='Total'">
												<td>
													<xsl:value-of
														select="stmtext:formatNumber(sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:cell[@id='total']/stmt:value), $baseCurrency)" />
												</td>
											</xsl:when>
											<xsl:otherwise>
												<xsl:choose>
													<xsl:when
														test="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/../stmt:metaData/stmt:entry[@key='ccy'] = $Ccy">
														<td>
															<xsl:value-of
																select="stmtext:formatNumber(sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral' and ../stmt:metaData/stmt:entry[@key='ccy'] = $Ccy]/stmt:cell[@id=$Ccy]/stmt:value), $Ccy)" />
														</td>
													</xsl:when>
													<xsl:otherwise>
														<td>0.0</td>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:if>
								</xsl:for-each>
							</tr>
							<tr class="SUB_TOTAL">
								<td>
									<xsl:attribute name="class">SUB_TOTAL</xsl:attribute>
									Net Excess/Deficit IM/VM
								</td>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
					         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
					         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
					            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
					            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<xsl:choose>
											<xsl:when test="$Ccy = 'Total'">
												<xsl:variable name="InitialMarginValue"
													select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:cell[@id='total']/stmt:value)" />
												<xsl:variable name="ClearingCashFlowValue"
													select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'Total Equity plus Pending Cash']/stmt:cell[@id = 'total']/stmt:value" />
												<td>
													<xsl:choose>
														<xsl:when test="string(number($InitialMarginValue)) = 'NaN'">
															<xsl:value-of select="stmtext:formatNumber($ClearingCashFlowValue, $baseCurrency)" />
														</xsl:when>
														<xsl:when test="string(number($ClearingCashFlowValue)) = 'NaN'">
															<xsl:value-of select="stmtext:formatNumber($InitialMarginValue, $baseCurrency)" />
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="stmtext:formatNumber($ClearingCashFlowValue+$InitialMarginValue, $baseCurrency)" />
														</xsl:otherwise>
													</xsl:choose>
												</td>
											</xsl:when>
											<xsl:otherwise>
												<xsl:variable name="ClearingCashFlowValue"
													select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'Total Equity plus Pending Cash']/stmt:cell[@id = $Ccy]/stmt:value" />
												<xsl:variable name="InitialMarginValue"
													select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral' and ../stmt:metaData/stmt:entry[@key='ccy'] = $Ccy]/stmt:cell[@id=$Ccy]/stmt:value)" />
												<td>
													<xsl:choose>
														<xsl:when test="string(number($InitialMarginValue)) = 'NaN'">
															<xsl:value-of select="stmtext:formatNumber($ClearingCashFlowValue, $Ccy)" />
														</xsl:when>
														<xsl:when test="string(number($ClearingCashFlowValue)) = 'NaN'">
															<xsl:value-of select="stmtext:formatNumber($InitialMarginValue, $Ccy)" />
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="stmtext:formatNumber($ClearingCashFlowValue+$InitialMarginValue, $Ccy)" />
														</xsl:otherwise>
													</xsl:choose>
												</td>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:if>
								</xsl:for-each>
							</tr>
							<xsl:for-each
								select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable' and @xsi:type='SectionElementListType']/stmt:sectionElement[@id='separateSettlementTables' and @xsi:type='TableType']/stmt:row[@id='Ending Balance plus Pending Separate Settlements']">
								<xsl:variable name="flowType" select="../stmt:metaData/stmt:entry[@key='INCLUDED_VM_FLOWS']" />
								<tr>
									<td>
										<xsl:call-template name="separateSettlementTitle">
											<xsl:with-param name="separateSettlement_ccp" select="../stmt:metaData/stmt:entry[@key='CCP']" />
											<xsl:with-param name="separateSettlement_product_type" select="../stmt:metaData/stmt:entry[@key='PRODUCT_TYPE']" />
											<xsl:with-param name="separateSettlement_included_vm_flows" select="$flowType" />
										</xsl:call-template>
									</td>
									<xsl:for-each select="../stmt:header/stmt:headerName[text() != 'Row Id']">
										<xsl:variable name="Ccy" select="." />
										<xsl:if
											test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
								         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
								         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
								            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
								            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
											<xsl:choose>
												<xsl:when test="$Ccy='Total'">
													<td>
														<xsl:value-of
															select="stmtext:formatNumber(../../stmt:row[@id='Ending Balance plus Pending Separate Settlements']/stmt:cell[@id='total']/stmt:value, $baseCurrency)" />
													</td>
												</xsl:when>
												<xsl:otherwise>
													<td>
														<xsl:value-of
															select="stmtext:formatNumber(../../stmt:row[@id='Ending Balance plus Pending Separate Settlements']/stmt:cell[@id=$Ccy]/stmt:value, $Ccy)" />
													</td>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:if>
									</xsl:for-each>
								</tr>
							</xsl:for-each>
							<tr class="SUB_TOTAL">
								<td>
									<xsl:attribute name="class">SUB_TOTAL</xsl:attribute>
									Net Excess/Deficit Separate Settlement
								</td>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
							         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
							         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
							            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
							            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<xsl:choose>
											<xsl:when test="$Ccy='Total'">
												<td>
													<xsl:value-of
														select="stmtext:formatNumber(sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:row[@id='Ending Balance plus Pending Separate Settlements']/stmt:cell[@id='total']/stmt:value), $baseCurrency)" />
												</td>
											</xsl:when>
											<xsl:otherwise>
												<td>
													<xsl:value-of
														select="stmtext:formatNumber(sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:row[@id='Ending Balance plus Pending Separate Settlements']/stmt:cell[@id=$Ccy]/stmt:value), $Ccy)" />
												</td>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:if>
								</xsl:for-each>
							</tr>
							<tr class="TOTAL">
								<td>
									<xsl:attribute name="class">TOTAL</xsl:attribute>
									Net Excess/Deficit IM/VM/Cash Events
								</td>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
							         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
							         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
							            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
							            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<xsl:choose>
											<xsl:when test="$Ccy='Total'">
												<xsl:variable name="IMVMExcessDeficit"
													select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:cell[@id='total']/stmt:value)" />
												<xsl:variable name="ClearingCashFlowValue"
													select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'Total Equity plus Pending Cash']/stmt:cell[@id = 'total']/stmt:value" />
												<xsl:variable name="SeparateSettlementExcessDeficit"
													select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:row[@id='Ending Balance plus Pending Separate Settlements']/stmt:cell[@id='total']/stmt:value)" />
												<td>
													<xsl:choose>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="0.0" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) !='NaN'">
															<xsl:value-of select="stmtext:formatNumber($SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) !='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="stmtext:formatNumber($ClearingCashFlowValue, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) !='NaN' and string(number($SeparateSettlementExcessDeficit)) !='NaN'">
															<xsl:value-of
																select="stmtext:formatNumber($ClearingCashFlowValue+$SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) !='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="stmtext:formatNumber($IMVMExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) !='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) !='NaN'">
															<xsl:value-of select="stmtext:formatNumber($IMVMExcessDeficit+$SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) !='NaN' and string(number($ClearingCashFlowValue)) !='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="stmtext:formatNumber($IMVMExcessDeficit+$ClearingCashFlowValue, $baseCurrency)" />
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of
																select="stmtext:formatNumber($IMVMExcessDeficit+$ClearingCashFlowValue+$SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:otherwise>
													</xsl:choose>
												</td>
											</xsl:when>
											<xsl:otherwise>
												<xsl:variable name="IMVMExcessDeficit"
													select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[@id='initialMarginTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral' and ../stmt:metaData/stmt:entry[@key='ccy'] = $Ccy]/stmt:cell[@id=$Ccy]/stmt:value)" />
												<xsl:variable name="ClearingCashFlowValue"
													select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'Total Equity plus Pending Cash']/stmt:cell[@id = $Ccy]/stmt:value" />
												<xsl:variable name="SeparateSettlementExcessDeficit"
													select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:row[@id='Ending Balance plus Pending Separate Settlements']/stmt:cell[@id= $Ccy]/stmt:value)" />
												<td>
													<xsl:choose>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="0.0" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) !='NaN'">
															<xsl:value-of select="stmtext:formatNumber($SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) !='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="stmtext:formatNumber($ClearingCashFlowValue, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) ='NaN' and string(number($ClearingCashFlowValue)) !='NaN' and string(number($SeparateSettlementExcessDeficit)) !='NaN'">
															<xsl:value-of
																select="stmtext:formatNumber($ClearingCashFlowValue+$SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) !='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="stmtext:formatNumber($IMVMExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) !='NaN' and string(number($ClearingCashFlowValue)) ='NaN' and string(number($SeparateSettlementExcessDeficit)) !='NaN'">
															<xsl:value-of select="stmtext:formatNumber($IMVMExcessDeficit+$SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:when>
														<xsl:when
															test="string(number($IMVMExcessDeficit)) !='NaN' and string(number($ClearingCashFlowValue)) !='NaN' and string(number($SeparateSettlementExcessDeficit)) ='NaN'">
															<xsl:value-of select="stmtext:formatNumber($IMVMExcessDeficit+$ClearingCashFlowValue, $baseCurrency)" />
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of
																select="stmtext:formatNumber($IMVMExcessDeficit+$ClearingCashFlowValue+$SeparateSettlementExcessDeficit, $baseCurrency)" />
														</xsl:otherwise>
													</xsl:choose>
												</td>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:if>
								</xsl:for-each>
							</tr>
							<tr>
								<td>FX Rates</td>
								<xsl:for-each
									select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:header/stmt:headerName[text() != 'Row Id']">
									<xsl:variable name="Ccy" select="." />
									<xsl:if
										test="not(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[@key='empty'] = $Ccy) or 
							         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']/stmt:metaData/stmt:entry[@key='empty' and text()=$Ccy]) !=
							         	count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='separateSettlementSummaryTable']/stmt:sectionElement[@id='separateSettlementTables']) or
							            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTable']/stmt:row[@id='Excess/Deficit Including Pending Collateral']/stmt:metaData/stmt:entry[@key='ccy'] = $Ccy) or
							            boolean(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:metaData/stmt:entry[@key='imCcys'] = $Ccy)">
										<xsl:choose>
											<xsl:when
												test="count(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:metaData/stmt:entry[text() = $Ccy]) = 0">
												<xsl:choose>
													<xsl:when test="$Ccy = 'Total'">
														<td>
															<xsl:value-of
																select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'FX Rates']/stmt:cell[@id = 'total']/stmt:value" />
														</td>
													</xsl:when>
													<xsl:otherwise>
														<td>
															<xsl:value-of
																select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='clearingCashFlowsSummaryTable']/stmt:row[@id = 'FX Rates']/stmt:cell[@id = $Ccy]/stmt:value" />
														</td>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:when>
											<xsl:otherwise>
												<td>0.0</td>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:if>
								</xsl:for-each>
							</tr>
						</table>

					</xsl:when>
					<xsl:otherwise>
						<xsl:apply-templates select="stmt:sectionElement[@id='summaryOfPaymentsTable']" />
					</xsl:otherwise>
				</xsl:choose>

				<!-- TRADE REPORTS -->
				<xsl:apply-templates select="stmt:sectionElement[@id='newTradesIRS']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='newTradesNDF']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='newTradesCreditDerivatives']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='newTradesFX']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='openTradesIRS']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='openTradesNDF']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='openTradesCreditDerivatives']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='openTradesFX']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='terminatedTradesIRS']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='terminatedTradesNDF']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='terminatedTradesCreditDerivatives']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='terminatedTradesFX']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='maturedTradesIRS']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='maturedTradesNDF']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='maturedTradesCreditDerivatives']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='maturedTradesFX']" />

				<!-- ACCOUNT ACTIVITY REPORTS -->
				<br />
				<br />
				<xsl:apply-templates select="stmt:sectionElement[@id='accountActivity']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='pendingAccountActivity']" />

				<!-- MARGIN ACTIVITY REPORTS -->
				<br />
				<br />
				<xsl:apply-templates select="stmt:sectionElement[@id='marginCallActivity']" />
				<xsl:apply-templates select="stmt:sectionElement[@id='pendingMarginCallActivity']" />

				<!-- MARGIN POSITION REPORTS -->
				<br />
				<br />
				<xsl:apply-templates select="stmt:sectionElement[@id='marginsOnDeposit']" />
			</div>
		</div>
		<br />
		<hr />
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='separateSettlementSummaryTable']">
		<xsl:choose>
			<xsl:when test="count(child::stmt:sectionElement[@id='separateSettlementTables'])=0">
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="title" select="@id" />
				<p class="SECTION_ELEMENT_TITLE">
					<xsl:value-of select="stmtext:getTranslation('title', $title)" />
				</p>
				<div class="SECTION_ELEMENT">
					<xsl:apply-templates select="stmt:sectionElement[@id='separateSettlementTables']" />
				</div>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="separateSettlementTitle">
		<xsl:param name="separateSettlement_ccp" />
		<xsl:param name="separateSettlement_product_type" />
		<xsl:param name="separateSettlement_included_vm_flows" />
		Separate Settlement
		<xsl:if test="boolean($separateSettlement_ccp) and $separateSettlement_ccp != ''">
			-
			<xsl:value-of select="$separateSettlement_ccp" />
		</xsl:if>
		<xsl:if test="boolean($separateSettlement_product_type) and $separateSettlement_product_type != ''">
			-
			<xsl:value-of select="$separateSettlement_product_type" />
		</xsl:if>
		-
		<xsl:value-of select="$separateSettlement_included_vm_flows" />
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='separateSettlementTables']">
		<xsl:variable name="metaDataNode" select="stmt:metaData" />
		<xsl:variable name="separateSettlement_ccp" select="stmt:metaData/stmt:entry[@key='CCP']" />
		<xsl:variable name="separateSettlement_product_type" select="stmt:metaData/stmt:entry[@key='PRODUCT_TYPE']" />
		<xsl:variable name="separateSettlement_included_vm_flows" select="stmt:metaData/stmt:entry[@key='INCLUDED_VM_FLOWS']" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:call-template name="separateSettlementTitle">
				<xsl:with-param name="separateSettlement_ccp" select="stmt:metaData/stmt:entry[@key='CCP']" />
				<xsl:with-param name="separateSettlement_product_type" select="stmt:metaData/stmt:entry[@key='PRODUCT_TYPE']" />
				<xsl:with-param name="separateSettlement_included_vm_flows" select="stmt:metaData/stmt:entry[@key='INCLUDED_VM_FLOWS']" />
			</xsl:call-template>
		</p>
		<xsl:choose>
			<xsl:when test="count(child::stmt:row)=0">
				<p class="DETAIL">No Activity.</p>
			</xsl:when>
			<xsl:otherwise>
				<table>
					<xsl:apply-templates select="stmt:header">
						<xsl:with-param name="translationsVar" select="'summary'" />
					</xsl:apply-templates>
					<xsl:apply-templates select="stmt:row" />
				</table>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='initialMarginSummaryTables']">
		<xsl:choose>
			<xsl:when test="count(child::stmt:sectionElement[@id='initialMarginTable'])=0">
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="title" select="@id" />
				<p class="SECTION_ELEMENT_TITLE">
					<xsl:value-of select="stmtext:getTranslation('title', $title)" />
				</p>
				<xsl:choose>
					<xsl:when test="count(child::stmt:sectionElement)=0">
						<p class="DETAIL">No Activity.</p>
					</xsl:when>
					<xsl:otherwise>
						<div class="SECTION_ELEMENT">
							<xsl:for-each select="stmt:metaData/stmt:entry[@key='imCcys']">
								<xsl:variable name="imCurrency" select="current()" />
								<p class="SECTION_ELEMENT_TITLE">
									<xsl:value-of select="$imCurrency" />
								</p>
								<table>
									<tr class="HEADER">
										<th></th>
										<xsl:for-each
											select="../../stmt:sectionElement/stmt:metaData[generate-id() = generate-id(key('clearingServicesKey', concat(stmt:entry[@key = 'ccp'], '|', stmt:entry[@key = 'product']))[1])]">
											<xsl:variable name="ccp" select="stmt:entry[@key = 'ccp']" />
											<xsl:variable name="service" select="stmt:entry[@key = 'product']" />
											<xsl:if
												test="sum(../../stmt:sectionElement[@id = 'initialMarginTable' and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency) and (stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp) and (stmt:metaData/stmt:entry[@key = 'product'] = $service and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)) and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)]/stmt:row/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value) != 0.0">
												<th>
													<xsl:value-of select="concat($ccp, ' ', $service)" />
												</th>
											</xsl:if>
										</xsl:for-each>
										<th>
											Total (
											<xsl:value-of select="$imCurrency" />
											)
										</th>
									</tr>

									<xsl:for-each select="../../stmt:sectionElement[stmt:metaData/stmt:entry[@key='ccy' = $imCurrency]][1]/stmt:row/@id">
										<xsl:variable name="vConcept" select="current()" />
										<tr>
											<xsl:choose>
												<xsl:when
													test="$vConcept='Total Collateral Plus Pending Collateral' 
                                                            or $vConcept='Excess/Deficit' 
                                                            or $vConcept='Excess/Deficit Including Pending Collateral'">
													<xsl:attribute name="class">TOTAL</xsl:attribute>
												</xsl:when>
												<xsl:when test="$vConcept='Total Collateral' or $vConcept='Total Pending Collateral'">
													<xsl:attribute name="class">SUB_TOTAL</xsl:attribute>
												</xsl:when>
											</xsl:choose>
											<td>
												<xsl:choose>
													<xsl:when
														test="$vConcept='Total Collateral Plus Pending Collateral' 
                                                               or $vConcept='Excess/Deficit' 
                                                               or $vConcept='Excess/Deficit Including Pending Collateral'">
														<xsl:attribute name="class">TOTAL</xsl:attribute>
													</xsl:when>
													<xsl:when
														test="$vConcept='Total Collateral' 
                                                               or $vConcept='Total Pending Collateral'">
														<xsl:attribute name="class">SUB_TOTAL</xsl:attribute>
													</xsl:when>
												</xsl:choose>
												<xsl:value-of select="$vConcept" />
											</td>

											<!-- Broken down services -->
											<xsl:for-each
												select="../../../stmt:sectionElement/stmt:metaData[generate-id() = generate-id(key('clearingServicesKey', concat(stmt:entry[@key = 'ccp'], '|', stmt:entry[@key = 'product']))[1])]">
												<xsl:variable name="ccp" select="stmt:entry[@key = 'ccp']" />
												<xsl:variable name="service" select="stmt:entry[@key = 'product']" />
												<xsl:variable name="rowSum"
													select="sum(../../stmt:sectionElement[stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp and stmt:metaData/stmt:entry[@key = 'product'] = $service]/stmt:row[@id = $vConcept]/stmt:cell[@id = $imCurrency])" />
												<xsl:if
													test="sum(../../stmt:sectionElement[@id = 'initialMarginTable' and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency) and (stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp) and (stmt:metaData/stmt:entry[@key = 'product'] = $service and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)) and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)]/stmt:row/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value) != 0.0">
													<td>
														<xsl:value-of select="stmtext:formatNumber($rowSum, $imCurrency)" />
													</td>
												</xsl:if>
											</xsl:for-each>
											<td>
												<xsl:value-of
													select="stmtext:formatNumber(sum(../../../stmt:sectionElement[stmt:metaData/stmt:entry[@key='ccy' = $imCurrency]]/stmt:row[@id=$vConcept]/stmt:cell[@id = $imCurrency]/stmt:value), $imCurrency)" />
											</td>
										</tr>
									</xsl:for-each>
									<xsl:call-template name="buildHaircutSection">
										<xsl:with-param name="imCurrency" select="$imCurrency" />
									</xsl:call-template>
								</table>
							</xsl:for-each>
						</div>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="buildHaircutSection">
		<xsl:param name="imCurrency" />
 		<xsl:variable name="vConcept" select="'Excess/Deficit Including Pending Collateral'"/>
		<xsl:variable name="totalValue" select="sum(/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[stmt:metaData/stmt:entry[@key='ccy' = $imCurrency]]/stmt:row[@id=$vConcept]/stmt:cell[@id = $imCurrency]/stmt:value)" />
		<xsl:variable name="totalHaircutValue">
			<xsl:for-each select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement/stmt:metaData[generate-id() = generate-id(key('clearingServicesKey', concat(stmt:entry[@key = 'ccp'], '|', stmt:entry[@key = 'product']))[1])]">
				<SumNodeValue>
					<value xsi:type="xs:decimal">
						<xsl:variable name="ccp" select="stmt:entry[@key = 'ccp']" />
						<xsl:variable name="service" select="stmt:entry[@key = 'product']" />
						<xsl:variable name="imTable" select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement[stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp and stmt:metaData/stmt:entry[@key = 'product'] = $service]" />
						<xsl:variable name="totalCcpCurrProdValue" select="sum($imTable/stmt:row[@id=$vConcept]/stmt:cell[@id = $imCurrency]/stmt:value)" />
						<xsl:variable name="hairCutgrp" select="my:getHaircutGrp($imTable, $totalCcpCurrProdValue)" />
						<xsl:variable xsi:type="xs:decimal"  name="hairCutValue" select="my:getHaircutValue($totalCcpCurrProdValue, $hairCutgrp)"/>
						<xsl:value-of select="$hairCutValue" />
					</value>
				</SumNodeValue>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="tempTotal" select="exslt:node-set($totalHaircutValue)"/>

		<xsl:if test="number(sum($tempTotal/SumNodeValue/value))">
			<tr>
				<xsl:attribute name="class">TOTAL</xsl:attribute>
				<td>FX Haircut %</td>
				<xsl:for-each select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement/stmt:metaData[generate-id() = generate-id(key('clearingServicesKey', concat(stmt:entry[@key = 'ccp'], '|', stmt:entry[@key = 'product']))[1])]">
					<xsl:variable name="ccp" select="stmt:entry[@key = 'ccp']" />
					<xsl:variable name="service" select="stmt:entry[@key = 'product']" />
					<xsl:variable name="imTable" select="../../stmt:sectionElement[@id = 'initialMarginTable' and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency) and (stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp) and (stmt:metaData/stmt:entry[@key = 'product'] = $service and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)) and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)]" />
					<xsl:if test="$imTable/stmt:row[@id=$vConcept]/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value != 0.0">
						<xsl:variable name="amount" select="$imTable/stmt:row[@id=$vConcept]/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value" /> 
						<xsl:variable name="hairCutgrp" select="my:getHaircutGrp($imTable, $amount)" />
						<td><xsl:value-of select="stmtext:formatNumber($hairCutgrp/hairCut,  $imCurrency)" /></td>
					</xsl:if>
				</xsl:for-each>
				<td>  </td>
			</tr>
	 		<tr>
				<xsl:attribute name="class">TOTAL</xsl:attribute>
				<td>Cross CCY Haircut vs Contract CCY(IM MCC)</td>
				<xsl:for-each select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement/stmt:metaData[generate-id() = generate-id(key('clearingServicesKey', concat(stmt:entry[@key = 'ccp'], '|', stmt:entry[@key = 'product']))[1])]">
					<xsl:variable name="ccp" select="stmt:entry[@key = 'ccp']" />
					<xsl:variable name="service" select="stmt:entry[@key = 'product']" />
					<xsl:variable name="imTable" select="../../stmt:sectionElement[@id = 'initialMarginTable' and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency) and (stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp) and (stmt:metaData/stmt:entry[@key = 'product'] = $service and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)) and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)]" />
					<xsl:if test="$imTable/stmt:row[@id=$vConcept]/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value != 0.0">
						<xsl:variable name="amount" select="$imTable/stmt:row[@id=$vConcept]/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value" /> 
						<xsl:variable name="hairCutgrp" select="my:getHaircutGrp($imTable, $amount)" />
						<xsl:variable xsi:type="xs:decimal"  name="hairCutValue" select="my:getHaircutValue($amount, $hairCutgrp)"/>
						<td><xsl:value-of select="stmtext:formatNumber($hairCutValue, $imCurrency)" /></td>
					</xsl:if>
				</xsl:for-each>
				<td> <xsl:value-of select="stmtext:formatNumber(sum($tempTotal/SumNodeValue/value), $imCurrency)"/> </td>
			</tr>
	
			<tr>
				<xsl:attribute name="class">TOTAL</xsl:attribute>
				<td>Haircutted Cash Coverage Requirement</td>
				<xsl:for-each select="/stmt:ClearingStatement/stmt:section[@id='financialSummary']/stmt:sectionElement[@id='initialMarginSummaryTables']/stmt:sectionElement/stmt:metaData[generate-id() = generate-id(key('clearingServicesKey', concat(stmt:entry[@key = 'ccp'], '|', stmt:entry[@key = 'product']))[1])]">
					<xsl:variable name="ccp" select="stmt:entry[@key = 'ccp']" />
					<xsl:variable name="service" select="stmt:entry[@key = 'product']" />
					<xsl:variable name="imTable" select="../../stmt:sectionElement[@id = 'initialMarginTable' and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency) and (stmt:metaData/stmt:entry[@key = 'ccp'] = $ccp) and (stmt:metaData/stmt:entry[@key = 'product'] = $service and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)) and (stmt:metaData/stmt:entry[@key = 'ccy'] = $imCurrency)]" />
					<xsl:if test="$imTable/stmt:row[@id=$vConcept]/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value != 0.0">
						<xsl:variable name="amount" select="$imTable/stmt:row[@id=$vConcept]/stmt:cell[@id != 'rowId' and @id != 'total']/stmt:value" /> 
						<xsl:variable name="hairCutgrp" select="my:getHaircutGrp($imTable, $amount)" />
						<xsl:variable xsi:type="xs:decimal"  name="hairCutAmount" select="my:getHaircutAmount($amount, $hairCutgrp)"/>
						<td><xsl:value-of select="stmtext:formatNumber($hairCutAmount, $imCurrency)" /></td>
					</xsl:if>
				</xsl:for-each>
				<td> <xsl:value-of select="stmtext:formatNumber(sum($tempTotal/SumNodeValue/value) + $totalValue, $imCurrency)"/> </td>
			</tr>
		</xsl:if>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='clearingCashFlowsSummaryTable' or @id='vmtsLedgerSummaryTable']">
		<xsl:variable name="title" select="@id" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:value-of select="stmtext:getTranslation('title', $title)" />
		</p>
		<xsl:choose>
			<xsl:when test="count(child::stmt:row)=0">
				<p class="DETAIL">No Activity.</p>
			</xsl:when>
			<xsl:otherwise>
				<table>
					<xsl:apply-templates select="stmt:header">
						<xsl:with-param name="translationsVar" select="'summary'" />
					</xsl:apply-templates>
					<xsl:apply-templates select="stmt:row" />
				</table>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='accountActivity' or @id='pendingAccountActivity']">
		<xsl:variable name="title" select="@id" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:value-of select="stmtext:getTranslation('title', $title)" />
		</p>
		<xsl:choose>
			<xsl:when test="count(child::stmt:row)=0">
				<p class="DETAIL">No Activity.</p>
			</xsl:when>
			<xsl:otherwise>
				<table>
					<xsl:apply-templates select="stmt:header">
						<xsl:with-param name="columnsToSkipVar" select="'accountActivity'" />
					</xsl:apply-templates>
					<xsl:apply-templates select="stmt:row">
						<xsl:with-param name="columnsToSkipVar" select="'accountActivity'" />
						<xsl:with-param name="translationsVar" select="'accountActivity'" />
					</xsl:apply-templates>
				</table>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='marginsOnDeposit']">
		<xsl:variable name="title" select="@id" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:value-of select="stmtext:getTranslation('title', $title)" />
		</p>
		<xsl:choose>
			<xsl:when test="count(child::stmt:row)=0">
				<p class="DETAIL">No Activity.</p>
			</xsl:when>
			<xsl:otherwise>
				<table>
					<xsl:apply-templates select="stmt:header" />
					<xsl:apply-templates select="stmt:row" />
				</table>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template
		match="stmt:sectionElement[@id='newTradesIRS' or @id='newTradesNDF' or @id='newTradesCreditDerivatives' or @id='newTradesFX' 
 					or @id='openTradesIRS' or @id='openTradesNDF' or @id='openTradesCreditDerivatives' or @id='openTradesFX' 
 					or @id='terminatedTradesIRS' or @id='terminatedTradesNDF' or @id='terminatedTradesCreditDerivatives' or @id='terminatedTradesFX' 
 					or @id='maturedTradesIRS' or @id='maturedTradesNDF' or @id='maturedTradesCreditDerivatives' or @id='maturedTradesFX']">
		<xsl:variable name="product" select="stmt:metaData/stmt:entry[@key='product']" />
		<xsl:variable name="productAvailable" select="../../stmt:metaData/stmt:entry[@key=$product]" />
		<xsl:if test="not($productAvailable) or $productAvailable='true'">
			<xsl:variable name="title" select="@id" />
			<p class="SECTION_ELEMENT_TITLE">
				<xsl:value-of select="stmtext:getTranslation('title', $title)" />
			</p>
			<table>
				<xsl:choose>
					<xsl:when test="count(child::stmt:row)=0">
						<p class="DETAIL">
							No trades for
							<xsl:value-of select="stmtext:getTranslation('title', $title)" />
						</p>
					</xsl:when>
					<xsl:otherwise>
						<xsl:apply-templates select="stmt:header" />
					</xsl:otherwise>
				</xsl:choose>
				<xsl:choose>
					<xsl:otherwise>
						<xsl:apply-templates select="stmt:row" />
					</xsl:otherwise>
				</xsl:choose>
			</table>
		</xsl:if>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='initialMarginSummaryTable']">
		<br />
		<xsl:variable name="title" select="@id" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:value-of select="stmtext:getTranslation('title', $title)" />
		</p>

		<xsl:variable name="sectionElement" select="." />
		<xsl:variable name="key" select="stmtext:getTranslation('title', $title)" />
		<xsl:variable name="currencies"
			select="stmt:row/stmt:metaData/stmt:entry[@key='ccy'][generate-id() = generate-id(key('marginsByCcy', text())[1])]" />
		<xsl:for-each select="$currencies">
			<xsl:variable name="ccy" select="." />
			<p class="SECTION_ELEMENT_SUB_TITLE">
				<xsl:value-of select="$ccy" />
			</p>
			<table>
				<xsl:apply-templates select="$sectionElement/stmt:header">
					<xsl:with-param name="translationsVar" select="'summary'" />
				</xsl:apply-templates>
				<xsl:apply-templates select="$sectionElement/stmt:row[stmt:metaData/stmt:entry[@key='ccy'] = $ccy]" />
			</table>
		</xsl:for-each>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='marginCallActivity' or @id='pendingMarginCallActivity']">
		<xsl:variable name="title" select="@id" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:value-of select="stmtext:getTranslation('title', $title)" />
		</p>

		<xsl:choose>
			<xsl:when test="count(child::stmt:row)=0">
				<p class="DETAIL">No Activity.</p>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="sectionElement" select="." />
				<xsl:variable name="key" select="@id" />
				<xsl:variable name="ccps"
					select="$sectionElement/stmt:row/stmt:metaData/stmt:entry[@key='ccp'][generate-id() = generate-id(key($key, text())[1])]" />
				<xsl:for-each select="$ccps">
					<xsl:variable name="ccp" select="." />
					<xsl:if test="$ccp!='VARIATION MARGIN'">
						<div class="SUB_SECTION_ELEMENT">
							<p class="SECTION_ELEMENT_SUB_TITLE">
								<xsl:value-of select="$ccp" />
							</p>
							<table>
								<xsl:apply-templates select="$sectionElement/stmt:header" />
								<xsl:apply-templates select="$sectionElement/stmt:row[stmt:metaData/stmt:entry[@key='ccp'] = $ccp]" />
							</table>
							<xsl:if test="$ccp!='VARIATION MARGIN' and $ccp!='Unallocated'">
								<div class="INNER_DIV">
									<p class="SECTION_ELEMENT_SUB_TITLE">
										Total
										<xsl:value-of select="$ccp" />
										:
										<xsl:value-of select="$sectionElement/stmt:metaData/stmt:entry[@key=concat('Total ',$ccp)]/text()" />
									</p>
								</div>
							</xsl:if>
						</div>
					</xsl:if>
				</xsl:for-each>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="stmt:sectionElement[@id='summaryOfPaymentsTable']">
		<br />
		<xsl:variable name="title" select="@id" />
		<p class="SECTION_ELEMENT_TITLE">
			<xsl:value-of select="stmtext:getTranslation('title', $title)" />
		</p>
		<table>
			<xsl:apply-templates select="stmt:header">
				<xsl:with-param name="translationsVar" select="'summary'" />
			</xsl:apply-templates>
			<xsl:apply-templates select="stmt:row" />
		</table>
	</xsl:template>
	<xsl:template match="stmt:header">
		<xsl:param name="columnsToSkipVar" />
		<xsl:param name="translationsVar" />
		<tr class="HEADER">
			<xsl:apply-templates select="stmt:headerName">
				<xsl:with-param name="translationsVar" select="$translationsVar" />
				<xsl:with-param name="columnsToSkipVar" select="$columnsToSkipVar" />
			</xsl:apply-templates>
		</tr>
	</xsl:template>

	<xsl:template match="stmt:headerName">
		<xsl:param name="translationsVar" />
		<xsl:param name="columnsToSkipVar" />
		<xsl:variable name="emptyColumns" select="../../stmt:metaData/stmt:entry[@key='empty']" />
		<xsl:variable name="column" select="." />
		<xsl:variable name="translation" select="stmtext:getTranslation($translationsVar, $column)" />

		<xsl:variable name="value">
			<xsl:choose>
				<xsl:when test="$translation = 'Total (__BASE_CURRENCY__)'">
					<!-- Ugly hack for non-EXSLT workaround: the document()// approach selects from the source XSL document, so there can 
						be no evaluations inside the translations vars. So far the only one is the base currency translation for total headers -->
					<xsl:value-of select="concat('Total (' , $baseCurrency , ')')" />
				</xsl:when>
				<xsl:when test="$translation">
					<xsl:value-of select="$translation" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="." />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="text()='Row Id'">
				<th></th>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="not(boolean($emptyColumns[text()=$column])) and not(contains($columnsToSkipVar,$column))">
					<th>
						<xsl:value-of select="$value" />
					</th>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="stmt:row">
		<xsl:param name="translationsVar" />
		<xsl:param name="columnsToSkipVar" />
		<xsl:if test="count(stmt:metaData/stmt:entry[@key='empty' and text()='true']) &lt; 1">
			<tr>
				<xsl:choose>
					<xsl:when
						test="@id='Ending Cash Balance' 
                           or @id='Total NPV' 
                           or @id='Beginning Cash Balance' 
                           or @id='Total Pending Cash'
                           or @id='Total Collateral' 
                           or @id='Total Pending Collateral' 
                           or @id='Total Collateral Plus Pending Cash' 
                           or @id='Excess/Deficit' 
                           or stmt:cell[@id='Type']/stmt:value='Closing Balance'
                           or @id='Beginning Separate Settlements Balance'
                           or @id='Ending Separate Settlements Balance'">
						<xsl:attribute name="class">SUB_TOTAL</xsl:attribute>
					</xsl:when>
					<xsl:when
						test="@id='Total Equity plus Pending Cash' 
                           or @id='Total Equity' 
                           or @id='Excess/Deficit Including Pending Collateral' 
                           or @id='Net Excess/Deficit'
                           or @id='Ending Balance plus Pending Separate Settlements'">
						<xsl:attribute name="class">TOTAL</xsl:attribute>
					</xsl:when>
				</xsl:choose>
				<xsl:apply-templates select="stmt:cell">
					<xsl:with-param name="translationsVar" select="$translationsVar" />
					<xsl:with-param name="columnsToSkipVar" select="$columnsToSkipVar" />
				</xsl:apply-templates>
			</tr>
		</xsl:if>
	</xsl:template>

	<xsl:template match="stmt:cell">
		<xsl:param name="translationsVar" />
		<xsl:param name="columnsToSkipVar" />
		<xsl:variable name="emptyColumns" select="../../stmt:metaData/stmt:entry[@key='empty']" />
		<xsl:variable name="sectionId" select="../../../@id" />
		<xsl:variable name="tableId" select="../../@id" />
		<xsl:variable name="rowId" select="../@id" />
		<xsl:variable name="cellId" select="@id" />
		<xsl:if test="not(boolean($emptyColumns[text()=$cellId])) and not(contains($columnsToSkipVar,$cellId))">
			<xsl:variable name="currentValue" select="stmt:value" />
			<xsl:variable name="translation" select="stmtext:getTranslation($translationsVar, $currentValue)" />
			<xsl:variable name="value">
				<xsl:choose>
					<xsl:when test="$translation">
						<xsl:value-of select="$translation" />
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="stmt:value" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>

			<td>
				<xsl:if test="count(child::stmt:value) != 0">
					<xsl:choose>
						<xsl:when
							test="$value='Total Equity' 
                              or $value='Total Equity plus Pending Cash'
                              or $value='Total Collateral Plus Pending Collateral' 
                              or $value='Excess/Deficit' 
                              or $value='Excess/Deficit Including Pending Collateral'
                              or $value='Ending Balance plus Pending Separate Settlements'">
							<xsl:attribute name="class">TOTAL</xsl:attribute>
						</xsl:when>
						<xsl:when
							test="$value='Beginning Cash Balance' 
                              or $value='Total NPV' 
                              or $value='Ending Cash Balance' 
                              or $value='Total Pending Cash' 
                              or $value='Total Collateral' 
                              or $value='Total Pending Collateral' 
                              or $value='Net Excess/Deficit'
                              or $value='Beginning Separate Settlements Balance'
                              or $value='Ending Separate Settlements Balance'">
							<xsl:attribute name="class">SUB_TOTAL</xsl:attribute>
						</xsl:when>
					</xsl:choose>
					<xsl:choose>
						<xsl:when
							test="($sectionId = 'financialSummary' or $sectionId='separateSettlementSummaryTable') and $tableId != 'initialMarginSummaryTable' and string(number($value)) != 'NaN' and $cellId = 'total' and $rowId != 'FX Rates'">
							<xsl:value-of select="stmtext:formatNumber($value, $baseCurrency)" />
						</xsl:when>
						<xsl:when
							test="($sectionId = 'financialSummary' or $sectionId='separateSettlementSummaryTable') and $tableId != 'initialMarginSummaryTable' and string(number($value)) != 'NaN' and $rowId != 'FX Rates'">
							<xsl:value-of select="stmtext:formatNumber($value, $cellId)" />
						</xsl:when>
						<xsl:when
							test="($sectionId = 'financialSummary' or $sectionId='separateSettlementSummaryTable') and $tableId = 'initialMarginSummaryTable' and string(number($value)) != 'NaN' and $rowId != 'FX Rates'">
							<xsl:value-of select="stmtext:formatNumber($value, ../stmt:metaData/stmt:entry[@key='ccy'])" />
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$value" />
						</xsl:otherwise>
					</xsl:choose>
				</xsl:if>
			</td>
		</xsl:if>
	</xsl:template>

	<func:function name="my:getHaircutGrp">
		<xsl:param name="imTable"/>
		<xsl:param name="amount"/>
		
		<xsl:variable name="hairCutGrp">
			<xsl:choose>
				<xsl:when test="$amount &gt; 0">
					<hairCut>
						<xsl:value-of select="$imTable/stmt:metaData/stmt:entry[@key='CP Haircut']"/>
					</hairCut>
					<hairCutType>
						<xsl:value-of select="$imTable/stmt:metaData/stmt:entry[@key='CP Haircut Type']"/>
					</hairCutType>
				</xsl:when>
				<xsl:otherwise>
					<hairCut>
						<xsl:value-of select="$imTable/stmt:metaData/stmt:entry[@key='PO Haircut']"/>
					</hairCut>
					<hairCutType>
						<xsl:value-of select="$imTable/stmt:metaData/stmt:entry[@key='PO Haircut Type']"/>
					</hairCutType>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<func:result select="exslt:node-set($hairCutGrp)" />
	</func:function>
	
	<func:function name="my:getHaircutPct">
		<xsl:param name="hairCutGrp"/>
		
		<xsl:variable name="hairCutPct">
			<xsl:choose>
				<xsl:when test="string($hairCutGrp/hairCutType) = 'Inverse'">
					<xsl:value-of select="(1 - 1 div ( 1 + $hairCutGrp/hairCut div 100 )) * 100" />
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$hairCutGrp/hairCut" />
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<func:result select="$hairCutPct" />
	</func:function>
	
	<func:function name="my:getHaircutAmount">
		<xsl:param name="amount"/>
		<xsl:param name="hairCutGrp"/>
		
		<xsl:variable name="hairCutPct" select="my:getHaircutPct($hairCutGrp)"/>

		<xsl:choose>
			<xsl:when test="$amount = 0">
				<func:result select="0.0" /> 
			</xsl:when>
			<xsl:when test="string(number($hairCutPct)) = 'NaN' or $hairCutPct = 0">
				<func:result select="$amount" /> 
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$amount &gt; 0 ">
						<func:result select="$amount * (1 - $hairCutPct div 100)" />
					</xsl:when>
					<xsl:otherwise>
						<func:result select="$amount * (1 + $hairCutPct div 100)" />
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</func:function>
	
	<func:function name="my:getHaircutValue">
		<xsl:param name="amount"/>
		<xsl:param name="hairCutGrp"/>
		
		<xsl:variable name="hairCutPct" select="my:getHaircutPct($hairCutGrp)"/>

		<xsl:choose>
			<xsl:when test="$amount = 0">
				<func:result xsi:type="xs:decimal" select="0.0" /> 
			</xsl:when>
			<xsl:when test="string(number($hairCutPct)) = 'NaN' or $hairCutPct = 0">
				<func:result xsi:type="xs:decimal" select="0" /> 
			</xsl:when>
			<xsl:otherwise>
				<func:result xsi:type="xs:decimal" select="$amount * ($hairCutPct div 100)" />
			</xsl:otherwise>
		</xsl:choose>
	</func:function>


</xsl:stylesheet>